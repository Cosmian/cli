---
name: CI checks

on:
  workflow_call:
    inputs:
      toolchain:
        required: true
        type: string
      debug_or_release:
        required: true
        type: string

jobs:
  cargo-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Install cargo-deny
        run: cargo install --locked cargo-deny
      
      - name: Run cargo-deny and capture output
        id: cargo-deny
        run: |
          # Run cargo-deny and capture both success and failure output
          set +e  # Don't fail on cargo-deny errors
          cargo deny check advisories > deny_output.txt 2>&1
          DENY_EXIT_CODE=$?
          set -e
          
          # Show the output for debugging
          echo "=== Cargo Deny Output ==="
          cat deny_output.txt
          echo "========================="
          
          # Check if there are any security vulnerabilities
          if [ $DENY_EXIT_CODE -ne 0 ]; then
            echo "cargo-deny found issues (exit code: $DENY_EXIT_CODE)"
            echo "deny_failed=true" >> $GITHUB_OUTPUT
          else
            echo "cargo-deny passed"
            echo "deny_failed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true
      
      - name: Parse RUSTSEC advisories and create issues
        if: steps.cargo-deny.outputs.deny_failed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a script to parse cargo-deny output and create issues
          cat > create_rustsec_issues.py << 'EOF'
          import os
          import subprocess
          import sys
          import re
          from typing import List, Dict, Set
          
          def get_existing_issues() -> Set[str]:
            """Get list of existing RUSTSEC issues to avoid duplicates"""
            try:
              cmd = ['gh', 'issue', 'list', '--limit', '100', '--json', 'title,number,state']
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              
              import json
              issues = json.loads(result.stdout)
              rustsec_ids = set()
              for issue in issues:
                # Extract RUSTSEC ID from title (format: "RUSTSEC-YYYY-NNNN: description")
                match = re.search(r'RUSTSEC-\d{4}-\d{4}', issue['title'])
                if match:
                  rustsec_ids.add(match.group(0))
              
              return rustsec_ids
            except Exception as e:
              print(f"Warning: Failed to get existing issues: {e}")
              return set()
          
          def create_rustsec_issue(rustsec_id: str, advisory_details: Dict[str, str]) -> bool:
            """Create a GitHub issue for a RUSTSEC advisory"""
            title = f"{rustsec_id}: {advisory_details.get('title', 'Security vulnerability')}"
            
            # Build detailed body from advisory information
            body_parts = []
            body_parts.append(f"**Vulnerability ID:** {rustsec_id}")
            
            if 'advisory_url' in advisory_details:
              body_parts.append(f"**Advisory:** {advisory_details['advisory_url']}")
            
            if 'description' in advisory_details:
              body_parts.append(f"**Description:**")
              body_parts.append(advisory_details['description'])
            
            if 'affected_crates' in advisory_details:
              body_parts.append(f"**Affected Crates:**")
              body_parts.append(advisory_details['affected_crates'])
            
            if 'solution' in advisory_details:
              body_parts.append(f"**Solution:** {advisory_details['solution']}")
            
            # Add automation note
            body_parts.append("---")
            body_parts.append("*This issue was automatically created by the security audit workflow.*")
            
            body = "\n\n".join(body_parts)
            
            try:
              # Create the issue
              cmd = ['gh', 'issue', 'create', '--title', title, '--body', body, '--label', 'security']
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              
              print(f"‚úÖ Created issue for {rustsec_id}: {title}")
              return True
            except subprocess.CalledProcessError as e:
              print(f"‚ùå Failed to create issue for {rustsec_id}: {e.stderr}")
              return False
          
          def parse_cargo_deny_output() -> List[Dict[str, str]]:
            """Parse cargo-deny output for RUSTSEC advisories"""
            advisories = []
            
            try:
              with open('deny_output.txt', 'r') as f:
                content = f.read()
              
              print(f"Parsing cargo-deny output ({len(content)} characters)")
              
              # Split content into individual vulnerability blocks
              # Look for "error[vulnerability]:" sections
              vulnerability_sections = re.split(r'\n(?=error\[vulnerability\]:)', content)
              
              for section in vulnerability_sections:
                if 'error[vulnerability]:' not in section:
                  continue
                  
                # Extract the title (first line after "error[vulnerability]:")
                title_match = re.search(r'error\[vulnerability\]: (.+)', section)
                title = title_match.group(1).strip() if title_match else "Security vulnerability"
                
                # Extract RUSTSEC ID
                rustsec_match = re.search(r'ID: (RUSTSEC-\d{4}-\d{4})', section)
                if not rustsec_match:
                  continue
                rustsec_id = rustsec_match.group(1)
                
                # Extract advisory URL
                advisory_match = re.search(r'Advisory: (https://rustsec\.org/advisories/RUSTSEC-\d{4}-\d{4})', section)
                advisory_url = advisory_match.group(1) if advisory_match else f"https://rustsec.org/advisories/{rustsec_id}"
                
                # Extract affected crate info
                crate_match = re.search(r'(\w+) ([\d.]+) registry\+', section)
                affected_crates = f"- {crate_match.group(1)} {crate_match.group(2)}" if crate_match else "Unknown crate"
                
                # Extract solution
                solution_match = re.search(r'Solution: (.+?)(?:\n|$)', section)
                solution = solution_match.group(1).strip() if solution_match else "Check advisory for solution"
                
                # Extract description (content between advisory line and solution/end)
                desc_match = re.search(r'Advisory: .+?\n(.*?)(?:Solution:|Announcement:|\Z)', section, re.DOTALL)
                description = desc_match.group(1).strip() if desc_match else "Check advisory for details"
                
                # Clean up description (remove markdown-style prefixes)
                description = re.sub(r'^\s*[‚îú‚îÇ‚îå‚îî]\s*', '', description, flags=re.MULTILINE)
                description = description.strip()
                
                advisory_details = {
                  'title': title,
                  'advisory_url': advisory_url,
                  'description': description,
                  'affected_crates': affected_crates,
                  'solution': solution
                }
                
                advisories.append({
                  'id': rustsec_id,
                  'details': advisory_details
                })
              
              # Fallback: simple RUSTSEC ID extraction if no structured parsing worked
              if not advisories:
                rustsec_ids = set(re.findall(r'RUSTSEC-\d{4}-\d{4}', content))
                for rustsec_id in rustsec_ids:
                  advisories.append({
                    'id': rustsec_id,
                    'details': {
                      'title': 'Security vulnerability detected',
                      'description': f'A security vulnerability was detected. Please check the advisory for details.',
                      'advisory_url': f'https://rustsec.org/advisories/{rustsec_id}'
                    }
                  })
              
              return advisories
              
            except Exception as e:
              print(f"Error parsing cargo-deny output: {e}")
              return []
          
          def main():
            print("üîç Checking for RUSTSEC advisories...")
            
            # Get existing RUSTSEC issues
            existing_rustsec_ids = get_existing_issues()
            print(f"üìã Found {len(existing_rustsec_ids)} existing RUSTSEC issues: {existing_rustsec_ids}")
            
            # Parse cargo-deny output
            advisories = parse_cargo_deny_output()
            print(f"üö® Found {len(advisories)} RUSTSEC advisories in cargo-deny output")
            
            created_count = 0
            for advisory in advisories:
              rustsec_id = advisory['id']
              if rustsec_id not in existing_rustsec_ids:
                if create_rustsec_issue(rustsec_id, advisory['details']):
                  created_count += 1
              else:
                print(f"‚è≠Ô∏è  Issue for {rustsec_id} already exists, skipping")
            
            print(f"‚ú® Created {created_count} new RUSTSEC issues")
          
          if __name__ == "__main__":
            main()
          EOF
          
          # Run the script
          python3 create_rustsec_issues.py
      
      - name: Fail job if vulnerabilities found
        if: steps.cargo-deny.outputs.deny_failed == 'true'
        run: |
          echo "‚ùå Security vulnerabilities were found by cargo-deny"
          echo "Issues have been automatically created for any new RUSTSEC advisories"
          exit 1

  cargo-lint:
    uses: Cosmian/reusable_workflows/.github/workflows/clippy.yml@develop
    with:
      toolchain: ${{ inputs.toolchain }}

  cargo-machete:
    uses: Cosmian/reusable_workflows/.github/workflows/cargo-machete.yml@develop
    with:
      toolchain: ${{ inputs.toolchain }}

  cargo-publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Publishing - dry run
        run: |
          cargo +nightly publish --dry-run --workspace -Z package-workspace \
            --exclude cosmian_findex_cli \
            --exclude cosmian_findex_client \
            --exclude cosmian_findex_structs \
            --exclude cosmian_findex_server \
            --exclude test_findex_server \
            --exclude cosmian_kms_access \
            --exclude cosmian_kms_cli \
            --exclude cosmian_kms_client_utils \
            --exclude cosmian_kms_crypto \
            --exclude cosmian_kms_base_hsm \
            --exclude cosmian_kms_proteccio \
            --exclude cosmian_kms_utimaco \
            --exclude cosmian_kms_softhsm2 \
            --exclude cosmian_kms_interfaces \
            --exclude cosmian_kms_kmip \
            --exclude cosmian_kms_kmip-derive \
            --exclude cosmian_kms_client \
            --exclude cosmian_kms_server \
            --exclude test_kms_server \
            --exclude cosmian_kms_server_database

      - name: Publishing
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          cargo +nightly publish --workspace -Z package-workspace --token ${{ secrets.CRATES_IO }} \
            --exclude cosmian_findex_cli \
            --exclude cosmian_findex_client \
            --exclude cosmian_findex_structs \
            --exclude cosmian_findex_server \
            --exclude test_findex_server \
            --exclude cosmian_kms_access \
            --exclude cosmian_kms_cli \
            --exclude cosmian_kms_client_utils \
            --exclude cosmian_kms_crypto \
            --exclude cosmian_kms_base_hsm \
            --exclude cosmian_kms_proteccio \
            --exclude cosmian_kms_utimaco \
            --exclude cosmian_kms_softhsm2 \
            --exclude cosmian_kms_interfaces \
            --exclude cosmian_kms_kmip \
            --exclude cosmian_kms_kmip-derive \
            --exclude cosmian_kms_client \
            --exclude cosmian_kms_server \
            --exclude test_kms_server \
            --exclude cosmian_kms_server_database

  build:
    uses: Cosmian/reusable_workflows/.github/workflows/build_all.yml@develop
    secrets: inherit
    with:
      toolchain: ${{ inputs.toolchain }}
      debug_or_release: ${{ inputs.debug_or_release }}

  ##############################################################################
  ### Releases
  ##############################################################################
  release:
    name: release
    needs:
      - cargo-audit
      - cargo-lint
      - build
    uses: Cosmian/reusable_workflows/.github/workflows/push-artifacts.yml@develop
    with:
      project-name: cli
      destination: cli # /mnt/packages/cli
      debug_or_release: ${{ inputs.debug_or_release }}

  public_documentation:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Deploy documentation in staging
        if: ${{ github.ref_name == 'develop' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: staging.yml
          repo: Cosmian/public_documentation
          ref: develop
          token: ${{ secrets.PAT_TOKEN }}

      - name: Deploy documentation in prod
        if: startsWith(github.ref, 'refs/tags')
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: prod.yml
          repo: Cosmian/public_documentation
          ref: main
          token: ${{ secrets.PAT_TOKEN }}
